#### 引用和指针在存放容器的区别
问题来源
在看框架代码时，遇到一段类似这样的代码
<pre><code>
struct ST_DATA{
	string key;
	int num;
};
class CDataCache{
	public:
		void append(ST_DATA &p_stData){
			vecDataCache.push_back(p_stData);
		}
	private:
		vector<ST_DATA>vecDataCache;
};
</pre></code>
看到这段，主要是对append函数的疑惑，引用传递结构体ST_DATA，然后将数据放到vector容器中。
问题就是:引用是原变量的别名，指向的内存为原变量所在的地址，如果原实参出了其作用域，那么
这块内存会自动释放，那么vector容器中，所存储的内容岂不是就消失了.
于是测试了一把
<pre><code>
struct ST_DATA{
	string key;
	int num;
};
class CDataCache{
	public:
		void append(ST_DATA &p_stData){
			vecDataCache.push_back(p_stData);
		}
		const ST_DATA & operator[](int p_iIndex)
        {
    		return vecDataCache[p_iIndex];
  		}
	private:
		vector<ST_DATA>vecDataCache;
};
CDataCache clDataCache;
void Test()
{
	ST_DATA stData;
	stData.key="key";
	stData.num=1;
	clDataCache.append(stData);
}
int main()
{
  Test();
	cout<<clDataCache[0].num<<endl;
	return 0;
}
</pre></code>
main函数中stData离开其所在的大括弧后会自动释放，在大括弧外仍然可以拿到clDataCache所
存储的值。
显然之前的理解有误，但程序又是怎样拿到释放的内存值的。
经过测试，这就是指针和引用其中一点的不同。** 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。**
依旧用代码测试看内存，来理解它
引用传递，地址变化
<pre><code>
struct ST_DATA{
	string key;
	int num;
};
class CDataCache{
	public:
		void append(ST_DATA &p_stData){
			cout<<"&p_stData "<<&p_stData<<endl;
			vecDataCache.push_back(p_stData);
			cout<<"&vecDataCache[0] "<<&vecDataCache[0]<<endl;
		}
		const ST_DATA & operator[](int p_iIndex)
        {
    		return vecDataCache[p_iIndex];
  		}
	private:
		vector<ST_DATA>vecDataCache;
};
CDataCache clDataCache;
void Test()
{
	ST_DATA stData;
	stData.key="key";
	stData.num=1;
	cout<<"&stData "<<&stData<<endl;
	clDataCache.append(stData);
}
int main()
{
  Test();
	cout<<clDataCache[0].num<<endl;
	return 0;
}
</pre></code>
运行结果

引用传递，其形参和实参地址相同，相当于同一个东西，当将其放入内存中时，会在vector所在的内存
空间重新申请空间放入形参内容。放入时调用了赋值构造函数
<pre><code>
struct ST_DATA{
		ST_DATA(){
		}
		ST_DATA(const ST_DATA& p_stData){
			cout<<"copy construct"<<endl;
		}
		string key;
		int num;
};
class CDataCache{
	public:
		void append(ST_DATA &p_stData){
			cout<<"&p_stData "<<&p_stData<<endl;
			vecDataCache.push_back(p_stData);
			cout<<"&vecDataCache[0] "<<&vecDataCache[0]<<endl;
		}
		const ST_DATA & operator[](int p_iIndex)
        {
    		return vecDataCache[p_iIndex];
  		}
	private:
		vector<ST_DATA>vecDataCache;
};
int main()
{
	CDataCache clDataCache;
	{
		ST_DATA stData;
		stData.key="key";
		stData.num=1;
		cout<<"&stData "<<&stData<<endl;
		clDataCache.append(stData);
	}
	cout<<clDataCache[0].num<<endl;
	return 0;
}
</pre></code>
此时若原append采用指针传递参数，又会是什么情况
<pre><code>
struct ST_DATA{
		string key;
		int num;
};
class CDataCache{
	public:
		void append(ST_DATA *p_stData){
			cout<<"*p_stData "<<p_stData<<endl;
			vecDataCache.push_back(p_stData);
			cout<<"&vecDataCache[0] "<<vecDataCache[0]<<endl;
		}
		/*const ST_DATA & operator[](int p_iIndex)
        {
    		return *vecDataCache[p_iIndex];
  		}*/
	public:
		vector<ST_DATA*>vecDataCache;
};
CDataCache clDataCache;
void Test(){
	ST_DATA stData;
	stData.key="key";
	stData.num=3;
	cout<<"*stData "<<&stData<<endl;
	clDataCache.append(&stData);
}
int main()
{
	Test();
	//cout<<clDataCache[0].num<<endl;
	cout<<clDataCache.vecDataCache[0]->num<<endl;
	cout<<clDataCache.vecDataCache[0]->key<<endl;
	return 0;
}
</pre></code>
容器内存放的是ST_DATA的指针，指针再指向其内容
从输出结果看，储存的指针的地址相同，但是当原实参离开其作用域后，其内存会被释放，因此
容器中指针指向的内容将不能得到。
结论：对于复杂数据结构（类，结构体）再放入容器中时，会调用其拷贝构造函数，因此当放入后，
容器内存储的内容和原内容没有关系，因此原数据内存释放后不会影响容器内的值。当容器内存放的
是基本数据类型（指针也是基本数据类型），那么在放入到容器内时，会将原值放入容器中（可能也
执行了拷贝过程，不过这不重要），以后还可以获得，但是对于指针来说，当其指向的内容为栈内存
时，在离开其作用于后，系统会动释放内存，也就不能获得其指向的内容，仅能获得指针的值
